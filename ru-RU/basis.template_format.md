# Формат шаблонов

Шаблоны описываются в формате `HTML`, но имеет несколько правил:

  * теги должны быть закрыты (либо иметь закрывающий тег, либо `<div/>`);

  * имена тегов и атрибутов регистрозависимы, лучше всегда писать их в нижнем регистре (это имеет значение на этапе разбора и сравнения);

  * значения должны быть в двойных кавычках;

  * между именем атрибута и равно, как и между равно и значением атрибута не должно быть пробелов.

Несмотря на эти правила, любой текст описания шаблона считается валидным, даже если описание является пустой строкой.

```html
<div class="example">
  <h1>Hello world!</h1>
</div>
```

Если нарушены правила, то шаблон может быть разобран неверно, то есть будет получен не тот результат, который ожидался. В случае ошибок исключения не выбрасываются.

При разборе шаблона игнорируются переводы строк и пробельные символы до и после перевода строки.

## Маркеры

Для обозначения специальных частей шаблона используются специальные маркеры – ссылки и биндинги. Маркеры описываются между фигурными скобками. Между фигурными скобками обычно указывается имя маркера, или список имен разделенных вертикальной чертой `|`. Проблелы не допускаются.

```html
<div class="item item_{selected}">
  <span class="item_title">{title}</span>
  <div{childNodesElement}/>
</div>
```
В данном примере задано три маркера: `{selected}`, `{title}` и `{childNodesElement}`. От расположения маркера зависит его значение.

Для имен маркеров действуют те же правила, что и для имен переменных `javascript`: в имени могут содержаться только латинские буквы (в любом регистре), цифры, знаки `_` и `$`; имя не может начинаться с цифры. Если правила не выполняются хотя бы для одного имени – игнорируется весь маркер.

Маркеры определяют как можно будет сослаться на определеную часть шаблона (ссылки) и куда будут применены данные (биндинги).

### Ссылки

Ссылки дают возможность ссылаться на определенный узел в экземпляре шаблона. Когда создается экземпляр шаблона, его DOM `фрагмент`, для него создается карта, где ключи – это названия ссылок, значения – узлы из его `DOM` фрагмента.

Ссылка может ссылаться только на один узел, но на один узел может ссылаться несколько ссылок. Можно сослаться на три типа узлов:

  * элемент (тег) – указывается после его имени;

  * комментарий – указывается после `<!--`, после маркера может любой текст;

  * текстовый узел – указывается вне описаний элементов и комментариев, такой маркер станет текстовым узлом в DOM фрагменте.

```html
<div{element}>
  {text}
  <!--{comment} это пример комментария с маркером -->
</div>
```

Все другие расположения маркеров ссылками не являются (могут являться биндингами или игнорироваться). Если одно и то же имя указано в нескольких маркерах, то ссылкой является последний.

```html
<div>
  <span{foo} class="first"></span>
  <span{foo} class="second"></span>
</div>
```

В данном случае ссылка `foo` будет ссылать на `<span>` с классом `second`.

Есть специальная ссылка `element`. Если маркер с таким именем не указан в шаблоне, то она добавляется первому узлу в шаблоне. В предыдущем примере `element` будет ссылаться на элемент `<div>`. Такое поведение является желательным в абсолютном большинстве случаех, поэтому маркер `element` практически никогда не указывается явно.

Ссылки используются для:

  * модификации описания шаблона, при его [вставке в другой шаблон](#binclude);

  * для того, чтобы владелец шаблона мог ссылаться на определенные узлы DOM фрагмента экземпляра шаблона.

### Биндинги

Биндинги используются для определения мест привязки значений (данных) к шаблону (частям его DOM фрагмента). Такие маркеры могут быть расположены:

  * после имени элемента (тега) – биндинг на элемент;

  * в комментарии, сразу после `<!--` – биндинг на комментарий;

  * вне описания элементов и комментариев – биндинг на текстовый узел;

  * внутри значения атрибута:

      * class – в зависимости от значения либо будет выставляться определенный класс, либо будет убираться;

        ```html
          <span class="item item_{selected} item_{state}"/>
        ```

      * style – может использоваться в секции значения свойства вместе с другими биндигами и дополнительным текстом;

        ```html
          <span style="color: {color}; background-position: {x}px {y}px; width: {progress}%"/>
        ```

      * остальные атрибуты – страновится частью выражения (сложения частей значения).

        ```html
          <input checked="{selected}" placeholder="Введите значение {foo} или {bar}"/>
        ```

Маркеры в атрибутах должны содержать только одно имя, иначе будут проигнорированы. Для одного узла может быть назначен только один биндинг, поэтому, если в маркере указано несколько имен, то биндингом будет является первое имя.

```html
<span title="{not|a|binding}">
  {title|value}
  <!--{comment|whatever}-->
</span>
```

В данном примере биндингами будут `title` и `comment`.

В зависимости от положения (типа) биндинга и значения, передаваемого в шаблон, применяются разные [правила](basis.template_bindings.md).

### XML well-formed

Указание маркеров с использование фигурных скобок является простым и наглядным, но делает описание не валидным с точки зрения `XML`. Если необходимо, чтобы описание было валидным `XML`, чтобы использовать его возможности, можно воспользоваться альтенативным способом указания маркеров.

Основная проблема, это маркеры для элементов. Вместо указания маркера в фигурных скобках после имени, можно использовать специальный атрибут `b:ref`.

```xml
<div class="item item_{example}">
  <span b:ref="title">{title}</span>
</div>
```

Маркеры в атрибутах, для текстовых узлов и комментариев не вызывают проблем.

> Технически, конечно, нужно так же определить пространство имен (namespace) `b`, которое используется в том числе и для специальных тегов шаблонов. 

## Специальная разметка

В описании шаблонов применяются дополнительные (специальные) теги. Такие теги предваряются префиксом `b:`, фактически определяя неймспейс и не создавая конфликтов с остальной разметкой.

## \<b:style>

Шаблоны могут подключать файлы стилей, которые они используют. Обычно рядом с файлом шаблона располагается файл с таким же именем, но с расширением `.css` содержащий стили к шаблону. Шаблон может подключать произвольное количество файлов стилей.

Тег имеет единственный атрибут `src`, в котором указывается путь к файлу стилей. Если описание шаблона находится в отдельном файле, то путь разрешается относительно него, иначе относительно корня приложения.

```html
<b:style src="item.css"/>

<div class="item">
  ...
</div>
```

> Ранее вместо `<b:style>` использовался тег `<b:resource>`, его еще можно встретить в шаблонах компонент `basis.js`. На данный момент они работают одинаково. Но в будущем планируется убрать поддержку `<b:resource>`, поэтому лучше его не использовать.

Стили подключаются на страницу, только когда создается первый экземпляр шаблона. Если несколько шаблонов используют один и тот же файл стилей, то он подключается только один раз. Если описание шаблона (шаблонов) изменяется так, что перестает использовать определенный файл стилей, и этот не используется другими шаблонами, то стиль изымается из страницы.

Если описание шаблона включает в себя другое описание, используя [\<b:include>](#binclude), и включаемое описание содержит подключение стилей (теги \<b:style>), то эти стили так же подключаются, как собственные. Если это является нежелательным поведением, то тегу `<b:include>` добавляется атрибут `no-style`.

Так как шаблоны могут инициироваться (когда создается их первый экземпляр) в любой момент, а так же могут подключать несколько файлов стилей в произвольном порядке, то нельзя полагаться на порядок подключения стилей. Обычно это не доставляет проблем, но это стоит учитывать, если в разных файлах стилей описываются правила с одинаковым весом ([specificity](http://www.w3.org/TR/selectors/#specificity)), применимые к элементу.

В сборке стили объединяются в один файл и динамического подключения/отключения стилей не происходит. Если используются темы, то генерируется несколько файлов стилей, в каждый из которых попадают только те стили, которые относятся к теме; при смене темы происходит смена используемого файла стилей (в один момент используется только один файл, соотвествующий текущей теме).

## \<b:l10n>

Для определения файла словаря, который используется шаблоном, используется тег `<b:l10n>`. Если описание шаблона находится в отдельном файле, то по умолчанию шаблон будет использовать словарь с таким же именем файла как имя шаблона, но с расширением `.l10n` (для шаблона `path/to/template.tmpl` будет использован файл `path/to/template.l10n`). Таким образом, использование `<b:l10n>` имеет смысл, только если нужно использовать другой файл или описание шаблона находится не в отдельном файле.

Тег имеет единственный атрибут `src`, в котором указывается путь к файлу словаря. Если описание шаблона находится в отдельном файле, то путь разрешается относительно него, иначе относительно корня приложения.

```html
<b:l10n src="path/to/dict.l10n"/>

<h1>{l10n:greeting}</h1>
```

`<b:l10n>` не влияет на подключаемые описания.

## \<b:define>

Этот тег используется для определения возможных значений биндинга. На данный момент, это влияет только на биндинги используемые в атрибуте `class`.

Когда биндинг используется в атрибуте `class`, необходимо знать какие значения он может принимать, для того чтобы:

  * образовывать правильные классы;

  * обнаруживать конфликты, когда одинаковые имена классов могут быть образованы разными биндингами, что может привести к ошибкам;

    > На данных момент такая проверка не делается, но она должна быть добавлена.

  * находить соответствия между классами в шаблонах и стилях, чтобы находить ненужные классы в шаблонах (для которых нет в стилях) и ненужные `CSS` правила (которые не используются шаблонами);

    > Этим занимается модуль сборщика `extractor`. Эту информацию получает в виде предупреждающих сообщений плагин.
    > С помощью флага `--css-cut-unused` сборщику можно указать, чтобы он вырезал не используемые в `CSS` правила. Но рекомендуется это делать самостоятельно на основе получаемых предупреждений.

  * минизировать имена классов в сборке.

    > Если все имена определены, для сборщика можно указать флаг `--css-optimize-names` и тогда он минимизирует имена классов в шаблонах и `CSS` до одно-/двух-буквенных, тем самым уменьшая размер сборки.

Тег имеет атрибуты:

  * name – имя биндинга для которого описывается правило;

  * type – тип устанавлеваемый для биндинга, может быть два значения:

      * bool – значение приводится к `boolean`, если значение тождественно `true`, то значением становится имя биндига и класс вставляется, иначе класс не вставляется;

      * enum – значение должно быть равно одному из списка (сравнивается оператором `==`, регистрозависимо), то это значение становится классом и вставляется, иначе класс не вставляется;

  * values – применимо только к типу `enum`, содержит список допустимых значений, разделеных пробелом;

  * default – значение по умолчанию:

    * для типа `bool` – если значение атрибута равно `true`, то значение по умолчанию `true`, при других значениях или если атрибут не указан, то значение по умолчанию – `false`;

    * для типа `enum` – если указано значение из списка (`values`), то оно будет по умолчанию, если значения нет в списке или атрибут не указан – по умолчанию будет пустая строка (класс не будет проставлен в эталон).

```html
<b:define name="selected" type="bool"/>
<b:define name="state" type="enum" values="processing ready error"/>

<div class="item item_{selected} item_{state}"/>
```

В данном примере, если значение для `selected` равноценно `true`, то будет вставлен класс `item_selected`, иначе такого класса у элемента не будет. Для `state` будут приниматься только три значения и образовываться классы `item_processing`, `item_ready` и `item_error`; при других значениях класс добавлен не будет.

Указание `default` позволяет вставить оптимизировать создание шаблона. Если известно, что некоторый биндинг при создании чаще всего имеет определенное значение, можно изначально проставить класс с этим значением и избежать операции вставки этого класса при создании экземпляра шаблона. Например, практически все экземпляры `basis.ui.Node` создаются с `selected` == `false` и `unselected` == `true`. Если в шаблоне используются оба значения, то выгоднее описать шаблон так:

```html
<b:define name="selected" type="bool"/>
<b:define name="unselected" type="bool" default="true"/>

<div class="item item_{selected} item_{unselected}"/>
```

Тогда эталонный `DOM` фрагмент, который клонируется при создании экземпляра шаблона, будет таким:

```html
<div class="item item_unselected"/>
```

И, в данном примере, при создании экземпляра шаблона никаких изменений в склонированом `DOM` фрагменте не будет.

## \<b:text>

Данный тег служит для альтернативного описания текстового узла. Его отличительная черта – все внутри этого тега воспринимается как текст и не разбирается по обычным правилам.

```html
<b:text>
  <div> – это не будет разобрано как тег и останется текстом
  маркеры тоже не разбираются, поэтому {example} не будет заменяться ни при каких условиях
</b:text>
```

Этим тегом удобно обрамлять текст, который не должен разбираться, например, пример исходного кода.

По умолчанию, если до первого или после последнего перевода строки идут только пробельные символы – они вырезаются.

```html
<b:text>
  1
  2
</b:text>
```

В данном примере, текстом будет строка "  1\n  2". Чтобы оставить текст без изменений используется атрибут `notrim`.

```html
<b:text notrim>
  1
  2
</b:text>
```

Здесь текстом будет "\n  1\n  2\n".

Можно добавить маркер на такой текстовый узел, используя атрибут `ref`.

## \<b:include>

`<b:include>` используется для включения в описание шаблона другого описания (шаблона).

Для тега можно указать следующие атрибуты:

  * `src` – ссылка на подключаемое описание, это может быть:

      * путь к файлу; если путь относительный (не начинается с `/`), то он разрешается относительно файла шаблона или относительно корня приложения, если описание находится не в отдельном файле;

        ```html
          <b:include src="path/to/file.tmpl"/>
        ```

      * имя шаблона определенное с помощью `basis.template.define` (подробнее ["Темы"](basis.template_theme.md))

        ```html
          <b:include src="foo.bar.baz"/>
        ```

      * ссылка вида `#N`, где N - идентификатор шаблона (значение свойства `templateId`); в основном используется внутренними механизмами.

        ```html
          <b:include src="#123"/>
        ```

  * `id` – этот атрибут будет назначен элементу с ссылкой `element` в вставляемом описании;

  * `class` – значение этого атрибута будет добавлено к значению атрибута `class` элемента со ссылкой `element`

Исходный шаблон:

```html
<b:include src="foo.tmpl" id="foo" class="extra-class with_{binding}"/>
```

foo.tmpl:

```html
<div class="example"/>
```

Результат:

```html
<div id="foo" class="example extra-class with_{binding}"/>
```

Внутри `<b:include>` могут быть другие специальные теги, предназначенные для модификации подключаемого описания:

  * `<b:before>` – содержимое этого тега вставляется перед узлом с указанной ссылкой; атрибут `ref` должен содержать название ссылки на узел; если такого атрибута нет или в подключаемом описании нет узла с такой ссылкой, то данный тег игнорируется;

    ```html
    <b:include src="foo.tmpl">
      <b:before ref="label">
        [inserted content]
      </b:before>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      [inserted content]
      <span{label}>{title}</span>
    </div>
    ```

  * `<b:after>` – работает так же как и `<b:before>`, но вставка происходит после элемента;

    ```html
    <b:include src="foo.tmpl">
      <b:after ref="label">
        [inserted content]
      </b:after>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label}>{title}</span>
      [inserted content]
    </div>
    ```

  * `<b:prepend>` – вставляет содержимое в начало элемента с указаной в атрибуте `ref` ссылкой; если атрибут отсутствует, то будет использовать ссылка `element`; если узла с такой ссылкой нет или узел не является элементом, то тег игнорируется;

    ```html
    <b:include src="foo.tmpl">
      <b:prepend ref="label">
        [inserted content]
      </b:prepend>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label}>[inserted content]{title}</span>
    </div>
    ```

  * `<b:append>` – работает так же, как и `<b:prepend>`, но вставляет содержимое в конец элемента;

    ```html
    <b:include src="foo.tmpl">
      <b:append ref="label">
        [inserted content]
      </b:append>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label}>{title}[inserted content]</span>
    </div>
    ```

  * `<b:replace>` – заменяет содержимым узел с указаной в атрибуте `ref` ссылкой; если узла с такой ссылкой нет, то тег игнорируется; если атрибут `ref` отсутствует, то заменяется узел с ссылкой `{element}`;

    ```html
    <b:include src="foo.tmpl">
      <b:replace ref="label">
        [new content]
      </b:replace>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      [new content]
    </div>
    ```

  * `<b:remove>` – заменяет содержимым узел с указаной в атрибуте `ref` ссылкой; если узла с такой ссылкой нет, то тег игнорируется; если атрибут `ref` отсутствует, то удаляется узел с ссылкой `{element}`;

    ```html
    <b:include src="foo.tmpl">
      <b:remove ref="label"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
      <span>{value}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span>{value}</span>
    </div>
    ```

  * `<b:attr>` и `<b:set-attr>` – уставливает атрибут с именем `name` и значением `value` элементу с ссылкой `ref`;

    ```html
    <b:include src="foo.tmpl">
      <b:attr ref="label" name="foo" value="bar"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label} foo="bar">{title}</span>
    </div>
    ```

  * `<b:append-attr>` – добавляет значение к значению атрибута;

    ```html
    <b:include src="foo.tmpl">
      <b:append-attr ref="label" name="foo" value="def"/>
      <b:append-attr ref="label" name="bar" value="baz"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label} foo="abc">{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label} foo="abcdef" bar="baz">{title}</span>
    </div>
    ```

  * `<b:remove-attr>` – удаляет атрибут;

    ```html
    <b:include src="foo.tmpl">
      <b:remove-attr ref="label" name="foo"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label} foo="abc">{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label}>{title}</span>
    </div>
    ```

  * `<b:class>` и `<b:append-class>` – добавляет класс (классы) в атрибут `class`;

    ```html
    <b:include src="foo.tmpl">
      <b:class ref="label" value="foo foo_{selected}"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label} class="bar">{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label} class="bar foo foo_{selected}">{title}</span>
    </div>
    ```

  * `<b:set-class>` – замещает значение атрибута `class` на новое значение;

    ```html
    <b:include src="foo.tmpl">
      <b:class ref="label" value="foo foo_{selected}"/>
    </b:inclide>
    ```

    foo.tmpl:

    ```html
    <div class="example">
      <span{label} class="bar">{title}</span>
    </div>
    ```

    Результат:

    ```html
    <div class="example">
      <span{label} class="bar foo foo_{selected}">{title}</span>
    </div>
    ```
