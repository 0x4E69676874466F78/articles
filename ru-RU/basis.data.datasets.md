# Наборы

Набор (dataset) – *неупорядоченное множество* объектов данных (на данный момент экземпляров `basis.data.Object` и его потомков). Они отвечают на вопрос: входит ли некоторый объект в их состав или нет. Так как набор это множество, то каждый объект в наборе присутствует в единственном экземпляре.

Основополагающим классом этой группы является `basis.data.ReadOnlyDataset`.

> До версии 1.3 этот класс назывался `AbstractDataset`.

Наборы бывают двух типов: пользовательские, имеющие интерфейс для изменения состава, и автоматические, состав которых определяется некоторым правилом.

Основные классы наборов описаны в пространстве имен `basis.data`, дополнительные в [`basis.data.dataset`](basis.data.dataset.md) (большая часть [автоматических наборов](basis.data.dataset.md)), `basis.data.index` и других.

## ReadOnlyDataset

`ReadOnlyDataset` является освопологающим классом для наборов, наследуется от `basis.data.AbstactData`. Экземпляры класса могут хранить данные, но не имеют интерфейса для модификации состава.

Наборы хранят элементы в виде хеш-таблиц (карт) или более сложных структур, поэтому чтобы получить список всех элементов набора, используется метод `getItems`. Количество элементов можно узнать с помощью свойства `itemCount`. Чтобы узнать входит ли элемент в состав набора используется метод `has`.

```js
console.log(dataset.getItems());
// console> [object, object, object]

console.log(dataset.itemCount);
// console> 3

console.log(dataset.has(dataset.pick()));
// console> true
```

Чтобы получить любой произвольный элемент набора используется метод `pick`, чтобы получить N (максимум) произвольных элементов – метод `top`.

```js
console.log(dataset.pick());
// console> object

console.log(dataset.top(2));
// console> [object, object]
```

Метод `forEach` позволяет выполнить некоторую функцию для всех элементов набора.

```js
dataset.forEach(function(item){
  console.log(item);
});
```

Когда меняется состав набора, выбрасывается событие `itemsChanged`. Обработчики получают параметр `delta` - изменения в наборе. Если добавлены новые элементы, то дельта содержит свойство `inserted`, массив с новыми членами, а если некоторые элементы удалены, то дельта содержит свойство `deleted`, массив с удаленными членами.

```js
someDataset.addHandler({
  itemsChanged: function(dataset, delta){
    if (delta.inserted)
      for (var i = 0, item; item = delta.inserted[i]; i++)
        console.log('item added', delta.inserted[i]);

    if (delta.deleted)
      for (var i = 0, item; item = delta.deleted[i]; i++)
        console.log('item removed', delta.deleted[i]);
  }
});
```

## Dataset

Класс `Dataset` предназначен для создания пользовательских наборов. Этот класс имеет методы для управления составом набора.

Основые операции с набором (методы):

  * `add(items)` - добавление элементов; 

  * `remove(items)` - удаление элементов;

  * `set(items)` - задать набор;

  * `sync(items)` - синхронизация (см. подробнее ниже);

  * `clear()` - очистить набор;

Методам `add`, `remove`, `set`, `clear` передается массив элементов. Для методов `add` и `remove` можно передать и одиночный объект. При выполнении методов дубликаты и значения не являющиеся экземплярами `basis.data.Object` – игнорируются.

В ходе выполнения методов составляется дельта изменений: какие элементы удалены и какие добавлены. Если дельта не пустая (хотя бы один элемент добавился или удалился), то выбрасывается событие `itemsChanged`.

Процесс синхронизации (метод `sync`) подразумевает сравнение текущего набора с переданным. В случае удаления элемента из набора, он разрушается (вызывается его метод `destroy`).

> Синхронизация работает слующим образом. Пусть текущий набор A, а переданный набор B. Если элемент присутствует в обоих наборах, то никаких действий не предпринимается. Если элемент есть только в A, но отсутствует в B, то элемент разрушается (вызывается его метод `destroy`). Если элемента нет в A, но есть в B, то он добавляется в A.

Можно задать состав набора при его создании, для этого используется свойство `items`.

```js
var dataset = new basis.data.Dataset({
  items: [
    ...
  ]
});
```

## resolveDataset

Многие классы позволяют подключать наборы. Нередко ссылка на набор хранится свойством некоторого объекта. Функция `resolveDataset` умеет получать ссылку на набор из некоторых типов объектов, и отслеживать изменения в исходном объекте, обновляя ссылку на набор. При этом создается специальный объект – адаптер, который хранит информацию о связи.

Функция принимает 4 параметра:
- `context` – объект, которому привязывается набор;
- `fn` – функция, выполняемая при изменении ссылки на набор;
- `source` – значение, из которого нужно получить ссылку на набор;
- `property` – свойство для хранения ссылки на адаптер.

Значение разрешается следующим образом. Если значение является функцией, то она вызывается (с контекстом `context`), а результат используется для разрешения ссылки на набор. Если значение `basis.data.DatasetWrapper`, то берется значение из свойства `dataset` и отслеживается его изменение (слушается событие `datasetChanged`). Иначе, если значение экземпляр класса `basis.data.Value`, то используется значение из свойства `value` и отслеживается его изменение (слушается событие `change`). Так же разрешаются объекты с интерфейсом `bindingBridge` (например, `basis.Token`). При этом значения `basis.data.Value` и объектов `bindingBridge` тоже разрешается с помощью `resolveDataset`. Если итоговое значение является экземпляром `ReadOnlyDataset`, то оно и возвращается, иначе возвращается `null`.

Таким образом поддерживаются следующие значения для получаения ссылки на набор:
- функция
- `basis.data.DatasetWrapper`
- `basis.data.Value`
- объект с `bindingBridge` (например, `basis.Token`)
- `basis.data.ReadOnlyDataset`

Обычно функция не используется самостоятельно, но ее используют различные методы. Например, `basis.data.DatasetWrapper#setDataset` или `basis.ui.Node#setDataSource`.

Так можно хранить ссылку на набор, например, в экземпляре `basis.data.Value`:

```js
var currentSet = new basis.data.Value();
var node = new basis.ui.Node({
  dataSource: currentSet
});

console.log(node.dataSource);
// console> null
// node.dataSourceAdapter_ - адаптер для currentSet
// node.dataSourceAdapter_.source === currentSet

currentSet.set(exampleDataset);
console.log(node.dataSource === exampleDataset);
// console> true
```

А вот так можно автоматизировать установку `dataSource` из одного из полей свойства `data`.

```js
var node = new basis.data.Node({
  dataSource: basis.data.Value.factory('update', 'data.items'),
  data: {
    items: new basis.data.Dataset()
  }
});

console.log(node.dataSource === node.data.items);
// console> true

console.log(node.dataSource);
// console> basis.data.Dataset {}

node.update({ items: null });
console.log(node.dataSource);
// console> null
```
