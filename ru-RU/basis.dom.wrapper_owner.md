# Паттерн "владелец" (owner)

Паттерн "владелец" используется экземплярами `basis.dom.wrapper.AbstractNode` (и его потомками), для ограничения числа объектов, которые влияют на экземпляр и/или на которые он влияет. Так экземпляр может иметь максимум одного владельца.

Данный паттерн утилизируется [сателлитами](basis.dom.wrapper_satellite.md), экземплярами `GroupingNode` (см [Группировка](basis.dom.wrapper_grouping.md)) и другими.

## Принцип работы

Экземпляры хранят ссылку на своего владельца в свойстве `owner`. Значение этого свойства задается либо при создании, либо вызовом метод `setOwner` в дальнейшем. В качестве значения методу передается экземпляр `basis.dom.wrapper.AbstractNode` или `null`. При изменении владельца (изменении свойства `owner`), выбрасывается событие `ownerChanged`, которое передает обработчикам значение свойства `owner` до изменения.

Владелец может ничего не знать об объектах, для которых является владельцем. Однако, чаще всего, имеет имеет ссылку на такие объекты. Например, на экземпляр `GroupingNode` ссылается свойство `grouping`, а на именованные сателлиты ссылки хранятся в свойстве `satellite`.

Обычно экземпляры разрушаются вместе с разрушением владельца, если эта логика не переопределена.

Для упрощения добавления обработчика событий владельца можно использовать свойство [listen](basis.event.ms#listen).

## parentNode vs. owner

У узла может быть установлен либо родительский узел (свойство `parentNode`), либо владелец (свойство `owner`). При вызове методов, которые меняют `parentNode` (методы `appendChild`, `insertBefore`, `replaceChild`, `setChildNodes`) при установленном `owner` (не равным `null`) выбрасывается исключение. То же самое происходит при вызове методов меняющие свойство `owner` (методы `setOwner`, `setSatellite`) при установленном `parentNode`.

> Наличие значений для обоих свойств `parentNode` и `owner` создает конфликтные ситуации, когда родитель и владелец одновременно влияют на узел или узел заимствует некоторые данные из родителя или владельца. Так же это делает возможным из деревовидной иерархии объектов получить граф содержащий циклы, что может привести к рекурсии и неоднозначности.

Чтобы дойти от узла к корню иерархии, нужно переходить по ссылке `parentNode` либо `owner`.

```js
var cursor = node;

while (cursor.parentNode || cursor.owner)
  cursor = cursor.parentNode || cursor.owner;

console.log(cursor, 'is root of', node);
```
